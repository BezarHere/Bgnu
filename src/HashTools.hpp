#pragma once
#include "misc/hash128.hpp"
#include "base.hpp"

#define FIELDVAR_HASH_DEF

struct HashTools
{
	static constexpr hash_t StartSeed = 0x1C2A9FA99DEB1ULL;
	static constexpr hash_t CipherTable[256] = {
		0x7AF1DFAC62D3C08A, 0xF879C600622E0489, 0x42752695549C3288, 0x8EA50040EC9E4F21,
		0xB62D28E18035101E, 0x57E76EF291AEEA9D, 0xCF6AB00BA2C1F71C, 0xC987D3DE883E1730,
		0x1EEC21274213A15F, 0x8B50CEB9805E85D4, 0x173340935462E2D8, 0x163DE975665CD930,
		0x41C3E7DE432C712B, 0x3F75B6053068A689, 0xC5885E79E2D1AE24, 0x700758BA6FC0FB66,
		0xB4AB6174D0F79CD7, 0x19F5F92EEBA57565, 0xADF434693B97BE66, 0xCC26CE15342B40FF,
		0x1A13F62AEA9B3FF8, 0x9891F69FC796EAFD, 0xE787A73F5ABC4DE6, 0xEDF3EB281A3BFF25,
		0xE32BBF973B90402D, 0xD2DE6A8AFD3C5BB0, 0xC13F38503215BBD2, 0xDEBBCD5281D16F09,
		0x3526B59874C92DD2, 0x13B297A1F6E631B5, 0xFB7B0498D31E5340, 0x280F95D2879D8928,
		0x5BE5CEC4F55ABA33, 0x584EC1D50AB76287, 0x4609D444C733B3E0, 0xCE718F7C729EAD07,
		0xC94098A258E4FEE4, 0xB0A271AC503C6BA1, 0x29EB38E478B5F603, 0x7C21AF050722FB63,
		0x3BE16425F1314CEB, 0x276DED13DED7D955, 0x205F7412B9468163, 0x988D4F962922D408,
		0xD4D1E564C5C244E0, 0x2C0A2D1FA85AEAD7, 0x5C4BDEB93C1555CB, 0xF8A045CA7C9A5608,
		0x51E471CCB80474EA, 0x184AB7967EB7B758, 0x7E2CC7D677875848, 0x38C95EFAF1F04803,
		0x91CD2D8972B24DD2, 0xF30DD58FEEA0BFCA, 0x3F6A8AA6E7472925, 0x57D45013090353E6,
		0xA1FF8FC182C429A4, 0x206CF35CF43FE658, 0x326BDE2AF4A5CED6, 0xA4549827DE3586F8,
		0x1492EC436D827D3F, 0x77D1CC5D3B27F040, 0x7A9AE95752632A64, 0xF03DBC41746BCBC4,
		0x1FF125DE89E431C2, 0x14DB88EA00D01893, 0x354EA11FF14159C8, 0x33B683E4EE0CA286,
		0x825E4E7766DE029A, 0xFFEE29B70F16B590, 0xF8CA52CE20C704E9, 0xF3CA32B73B25178E,
		0x1800470317BE790C, 0xBFE2F4DE32B6DC50, 0x33FFFA89FFCE1D38, 0xFAA20F9070911409,
		0x684BF8B5D810C6CF, 0x9AB9751461762831, 0xA7789BBE3BA4E72B, 0xCE0F2DDCB0CE03F6,
		0x209A8CD3EFBDAA13, 0xF62A103D830BFB21, 0xCF427A38037C3288, 0xC4EDF600C94F634C,
		0x3ECB65FBF020A0C4, 0x1EC904999A32FB18, 0xDAB4A0C50E7E5184, 0xE034D0A1E94CE36D,
		0x105E8208CC069226, 0xA6393D1579FA7F03, 0x26DB61E0569C3C7C, 0xDF4151408A46725B,
		0xEBF5E5AD32075C2F, 0x9325784EAA667CD4, 0x569C403BBA6882E8, 0x2CBD71B845696478,
		0x7624A830F1E5FA3D, 0x9E9BFFDFB4348369, 0xDE4391D75B00AD12, 0x987BE4545F0F9A57,
		0x7455C6167A426FF7, 0x458139E1E1A140B4, 0x32288574EFEDD10B, 0x9541166787D027FB,
		0x31E54F4352142427, 0xEA28EC0A33A6C132, 0x2EC35D453E270169, 0x8AFD1346D1E47900,
		0x7E0534F2E777DCAF, 0x82B78AA6F367E5F4, 0x165E15E49D2A03B3, 0x5C8F85076ACEF00F,
		0x6E80A9A23D2E0072, 0x942F02F393101938, 0x6355C8D108058722, 0x31BAA02BDF064E3C,
		0x82F189241BC48B2B, 0x193F0858364EFAB6, 0xEF903D5F0DB92DEB, 0x3D9FF376706624BF,
		0x10FEF09090EA814A, 0x69F9C9B6B118BB0F, 0x90496659A196EDCE, 0x17F88A39FBD1E99D,
		0xEF86F893E2C1D475, 0x51A55EA1A55C88B3, 0xB5E0994121F8AF16, 0x2E59419075A9B878,
		0xAE7DD1A80FB3C15E, 0x9FCF22302B2114E1, 0x58445B5FB4BCACF2, 0x3AC419A7BC1E40AD,
		0x3E30BECB9677EEE9, 0x4681ABFA5614FD2C, 0xA084269D7B4417A9, 0x3E88B41A26472FEB,
		0xD02E82908D17EE91, 0x92280A68096FCE01, 0x15F814E585029648, 0x6570188118940BBA,
		0x120E75167C9D1222, 0x6EF976C80DDCFA7A, 0xD6C45DB5B1FCAD70, 0x127A57E6E87BBB2E,
		0xD3AB99E1937401FA, 0xBBD90471AB7EC032, 0xD111BE0E7169275D, 0x43BFE838E7F5422D,
		0xF9635DB0D462EFA0, 0x4AB6B94A70554666, 0xF5A1CFB16B6C5D38, 0x2BE13F27130F5B3F,
		0xC9897658FFC87A7F, 0x2751E6EC0EBFCD45, 0xACDCAC6CFEE51529, 0xA8C31645436A7C5E,
		0x3F2AA8C93D7D318D, 0x50B5D78A2745C31C, 0x5C73FCA4823B2C69, 0x60FB7CA85BAC1019,
		0x38F7FE27305C92AA, 0x30A2DA45FEF99A6A, 0xB58F6535A10DA18C, 0x4B09E5E77FDEBCE8,
		0x8F2DC006E76D92E9, 0x6EF0D4ABFB2D5365, 0xB4780D40E325818C, 0xC4D1230CB44923DF,
		0xBCF6D66B805B0190, 0xA9B2F542F2DC1DE2, 0x3DFF8C2D21E44CDE, 0x4A9401E554EFBE85,
		0x5739056D66194F57, 0xD70830DEBB65FB8C, 0x865512CA31EA3B25, 0x46724EB6D261649A,
		0x6BAA17CBAB283FDD, 0x954CB2413D00ECB9, 0x2B4AC04CDF70EB3F, 0xBB8529AF26BC1BC6,
		0xDD5FA5CC1D4DE3B1, 0x5C24715BCAB3751D, 0xA32E6E2BEC82FF25, 0x81D53CF5D8BE823A,
		0x94D837FBF81F45EB, 0xD19733FFF209AEE7, 0xFAE787308C6219AB, 0x8CB13E965F6B2363,
		0xBC3474D69868D085, 0x2601776FB8CB3FF5, 0xA9A4F90CFF0159B6, 0xEC796D47A4E9D2E1,
		0xDAA34757835248C9, 0x9A8EE8B1937C4FC4, 0x719A830735CE8DE5, 0x9212FCEA9776B932,
		0xD4F2A6F5736A5994, 0x55E7667ACB24B434, 0x6B9386637C38CEAA, 0x1A0BA7AC1A97CD81,
		0xAD6E1715FD411A3D, 0xDCE9A03A20F00B45, 0xD23B37AC2CC5E891, 0x1C5D6CF0E931B942,
		0x8D34F7BCACBD164B, 0x35D777674A4404BA, 0x254BE3EC09CCF23E, 0x2992CA0EA77BF429,
		0x8105E6AB30E275A9, 0x8AC1A33257336B61, 0xB0CBD0B566F77A7D, 0x319CF7D4F7370DDF,
		0x420BEDA1942D2B9B, 0x296CE845CDFA8154, 0x2B2ACE7F792F12BF, 0x23F334AD17E54D0F,
		0xB44D122100960F72, 0x7D674C23A0C11F9F, 0x947D5E122E741202, 0x1D51E7ACA0B27EF6,
		0x308C0FE2D5EC71FE, 0xBC4333C8E45B7CA1, 0xE97AE5ACD3C39205, 0x1079CA663B8B5E87,
		0x150EE69432DCC4E7, 0xF9D113763064F8D3, 0x997824A7E6606935, 0x5CBF2BE02D01E223,
		0x263E4AFD966D5596, 0xEB0515BA6A5725BE, 0x9B9ACEFB1280CA79, 0x90B9DBA6FAE1D1CA,
		0x154C9E96C0BC60D6, 0x4488E5CEF171DC3E, 0x2B4257CF216A43EB, 0x2435C7CB9B5FAE03,
		0xD55C981127FC7D18, 0xB50DF81B8CFAE857, 0x835C40E6E918A3FD, 0xC13DE8C5FB54FACE,
		0xECCEEBD7309B7467, 0xF39353365AC8924E, 0x1FF41B6AB28F9CA1, 0x1763AD6BEC5110C6,
		0x1BE6CE2757E60A3A, 0x388351F0B5773A77, 0xE1FCA928826C91A2, 0xBFBED59F8E4B35D8,
		0x40AA92C0A4099419, 0x90F48C4787FB791A, 0x18DF2A72AA672ED8, 0x30FC434D81C8E286,
		0x9A15FE25A41AE366, 0x418EAF529F214B55, 0x516C700609E35445, 0x944D0DF0CDEB0C07
	};

	static constexpr hash_t hash(hash_t left, hash_t right);

	static inline constexpr hash_t combine(hash_t left, hash_t right) {
		return hash(left, right);
	}

	template <typename... _Hashes>
	static inline constexpr hash_t combine(hash_t left, hash_t right, _Hashes &&...hashes) {
		return combine(left, right, std::forward<_Hashes>(hashes)...);
	}

	inline static hash_t hash(const StrBlob &data, hash_t seed = StartSeed);

	// only recommend for simple types
	template <typename T>
	inline static hash_t hash(const T &obj, hash_t seed = StartSeed);

	// only recommend for simple types
	template <typename T>
	inline static hash_t hash(const Blob<const T> &objs, hash_t seed = StartSeed);

	// only recommend for simple types
	template <typename T>
	inline static hash_t hash(const T *objs, size_t count, hash_t seed = StartSeed) {
		return hash({objs, count}, seed);
	}

	// only recommend for simple types
	template <typename T, size_t N>
	inline static hash_t hash(const T(&objects)[N], hash_t seed = StartSeed);
};

struct HashDigester
{
	inline HashDigester() = default;
	inline HashDigester(const hash_t &seed) : value{seed} {}

	template <typename... _Args>
	inline HashDigester &add(_Args &&...args) {

		value = HashTools::hash(std::forward<_Args>(args)..., value);

		return *this;
	}

	template <typename T>
	inline HashDigester &operator+=(const T &obj) {
		return add(obj);
	}

	inline hash_t hash() const noexcept {
		return value;
	}

	hash_t value = HashTools::StartSeed;
};

inline constexpr hash_t HashTools::hash(hash_t left, hash_t right) {
	return (left ^ StartSeed) ^ ~_rotr64(right, 21);
}

inline hash_t HashTools::hash(const StrBlob &data, hash_t seed) {
	for (size_t i = 0; i < data.size; i++)
	{
		seed ^= _rotr64(CipherTable[(uint8_t)data[i]], (int)i);
	}

	return seed;
}

template<typename T>
inline hash_t HashTools::hash(const T &obj, hash_t seed) {
	return hash(hash_t(obj.hash()), seed);
}

template<typename T>
inline hash_t HashTools::hash(const Blob<const T> &objs, hash_t seed) {
	for (size_t i = 0; i < objs.size; i++)
	{
		seed = hash(hash_t(obj.hash()), seed);
	}
	return hash_t();
}

template<typename T, size_t N>
inline hash_t HashTools::hash(const T(&objects)[N], hash_t seed) {
	return hash({objects, N}, seed);
}
