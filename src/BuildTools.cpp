#include "BuildTools.hpp"

#include <fstream>
#include <vector>

#include "FilePath.hpp"
#include "Settings.hpp"
#include "base.hpp"
#include "utility/Process.hpp"
#include "utility/ThreadBatcher.hpp"

using namespace build_tools;

static bool DoesSourceTypeDominate(SourceFileType type, SourceFileType target);
static void GenerateJoinArgs(const Blob<const ExecuteParameter> &params, std::string *results);

void build_tools::WriteAutoGeneratedHeader(std::ostream &stream) {
  std::time_t now = std::chrono::system_clock::to_time_t(std::chrono::system_clock::now());

  stream << "# This file is temporay and was generated on "
         << std::put_time(std::localtime(&now), "%Y-%m-%d %X") << '\n'
         << "# written by bgnu " << Settings::GetVersion() << '\n';
}

vector<FilePath> build_tools::GetAllFilesInDirectory(const FilePath &path, bool recursive) {
  vector<FilePath> entries{};
  vector<FilePath::iterator> iterators{};

  iterators.push_back(path.create_iterator());

  while (!iterators.empty())
  {
    const auto current_iter = iterators.back();
    iterators.pop_back();

    for (const auto &path : current_iter)
    {
      if (path.is_directory())
      {
        if (recursive)
        {
          iterators.emplace_back(path);
        }
        continue;
      }

      if (path.is_regular_file())
      {
        entries.push_back(path);
        continue;
      }

      // skips other non-regular files
    }
  }

  return entries;
}

string build_tools::EscapeQuotes(const StrBlob &str) {
  string result = {};
  result.reserve(str.size);

  for (size_t i = 0; i < str.size; i++)
  {
    if (str[i] == '"')
    {
      result.push_back('\\');
    }

    result.push_back(str[i]);
  }

  return result;
}

SourceFileType build_tools::GetSourceType(const StrBlob &path) {
  return SourceTools::get_extension_file_type(FilePath::GetExtension(path));
}

bool build_tools::IsCompilableSourceFile(const StrBlob &path) {
  return SourceTools::is_extension_compilable(FilePath::GetExtension(path));
}

void build_tools::DeleteBuildCache(const Project &project) {
  project.get_output().cache_dir->remove_recursive();
}

void build_tools::DeleteBuildDir(const Project &project) {
  DeleteBuildCache(project);
  project.get_output().dir->remove_recursive();
}

void build_tools::SetupHashes(BuildCache &cache,
                              const Project &proj,
                              const BuildConfiguration *config) {
  cache.build_hash = proj.hash();
  cache.config_hash = config->hash();
}

void build_tools::DeleteUnusedObjFiles(const std::set<FilePath> &object_files,
                                       const std::set<FilePath> &used_files) {
  for (const auto &obj : object_files)
  {
    if (used_files.contains(obj))
    {
      continue;
    }

    if (obj.is_file())
    {
      obj.remove();
    }
  }
}

#define EXECUTE_CHECK_ERR()                                                                    \
  if (error != EOK)                                                                            \
  {                                                                                            \
    Logger::error("failed to execute params in function %s with error=%s, check above logs^^", \
                  __FUNCTION__,                                                                \
                  GetErrorName(error));                                                        \
  }

std::vector<int> build_tools::Execute(const Blob<const ExecuteParameter> &params) {

  std::vector<std::string> joined_commands{};
  joined_commands.resize(params.length());

  GenerateJoinArgs(params, joined_commands.data());

  vector<int> results{};
  results.resize(params.length());

  const errno_t error = _Execute_Inner({ joined_commands.data(), joined_commands.size() },
                                       params,
                                       { results.data(), results.size() });

  EXECUTE_CHECK_ERR();

  return results;
}

std::vector<int> build_tools::Execute_Multithreaded(const Blob<const ExecuteParameter> &params,
                                                    uint32_t batches) {

  std::vector<std::string> joined_commands{};
  joined_commands.resize(params.length());

  GenerateJoinArgs(params, joined_commands.data());

  vector<int> results{};
  results.resize(params.length());

  const errno_t error = _ExecuteParallel_Inner({ joined_commands.data(), joined_commands.size() },
                                               params,
                                               { results.data(), results.size() },
                                               batches);

  EXECUTE_CHECK_ERR();

  return results;
}

errno_t build_tools::_Execute_Inner(const Blob<const std::string> &args,
                                    const Blob<const ExecuteParameter> &params,
                                    Blob<int> results) {
  for (size_t i = 0; i < args.size; i++)
  {
    const auto &param = params[i];
    Process process{ args[i] };
    process.set_name(param.name.c_str());

    if (HAS_FLAG(param.flags, eExcFlag_Printout))
    {
      Logger::notify("executing '%s'...", param.name.c_str());
    }

    results[i] = process.start(param.out);

    if (HAS_FLAG(param.flags, eExcFlag_Printout))
    {
      Logger::notify("executing '%s' resulted in code %d [%llu / %llu]",
                     param.name.c_str(),
                     results[i],
                     i,
                     args.size);
    }
  }

  return EOK;
}

errno_t build_tools::_ExecuteParallel_Inner(const Blob<const std::string> &args,
                                            const Blob<const ExecuteParameter> &params,
                                            Blob<int> results,
                                            uint32_t batches) {
  std::atomic_size_t progress_index = 0;
  const auto func = [&args, &params, &progress_index](size_t index) {
    const auto &param = params[index];
    Process process{ args[index] };

#ifdef __linux__
    process.add_flags(Process::Flag_InheritEnv);
#endif
    process.set_name(param.name.c_str());

    Logger::verbose("processing parallel: '%s'", args[index].c_str());

    if (HAS_FLAG(param.flags, eExcFlag_Printout))
    {
      Logger::notify("executing '%s'...", param.name.c_str());
    }

    const int result = process.start(param.out);
    progress_index++;

    if (HAS_FLAG(param.flags, eExcFlag_Printout))
    {
      const auto log_func = (result == EOK) ? Logger::notify : Logger::warning;
      log_func("executing '%s' resulted in %s [%d] [%llu / %llu]",
               param.name.c_str(),
               GetErrorName(result),
               result,
               (size_t)progress_index,
               args.size);
    }

    return result;
  };

  const auto exporter = [&results](size_t index, int result) { results[index] = result; };

  ThreadBatcher batcher = { batches, func, exporter };

  batcher.run(args.size);

  return errno_t();
}

SourceFileType build_tools::GetDominantSourceType(Blob<const SourceFileType> file_types) {
  SourceFileType dominate_type = SourceFileType::None;

  for (SourceFileType type : file_types)
  {
    if (DoesSourceTypeDominate(type, dominate_type))
    {
      dominate_type = type;
    }
  }

  return dominate_type;
}

void build_tools::TryCreateClangdCompileFlagsFile(const BuildConfiguration &config,
                                                  const FilePath &build_folder) {
  const FilePath compile_flags_file = build_folder.join_path("compile_flags.txt");
  if (compile_flags_file.is_file() && !compile_flags_file.is_empty())
  {
    return;
  }

  vector<string> flags{};
  config.build_clangd_contents(flags);

  auto file = compile_flags_file.stream_write(false);
  for (const string &s : flags)
  {
    file << s;
    file << '\n';
  }
}

void build_tools::WriteClangdCompileCommandsFile(const std::string *args,
                                                 const std::string *names,
                                                 size_t count,
                                                 const FilePath &build_folder) {

  const FilePath compile_cmds_path = build_folder.join_path("compile_commands.json");
  auto file = compile_cmds_path.stream_write(false);

  file << "[";

  for (size_t i = 0; i < count; i++)
  {
    file << "\n\t{\n";

    file << "\t\t";
    file << "\"directory\": " << '"' << EscapeQuotes(build_folder) << '"' << "\n,";
    file << "\t\t";
    file << "\"command\": " << '"' <<  EscapeQuotes(args[i]) << '"' << "\n,";

    file << "\t\t";
    file << "\"file\": " << '"' << EscapeQuotes(names[i]) << '"' << "\n";

    file << "\t},";
  }

  file << "\n]";
}

SourceFileType build_tools::DefaultSourceFileTypeForFilePath(const FilePath::char_type *path) {
  const size_t extension_index = string_tools::find_last(path, '.', FilePath::MaxPathLength);
  const size_t path_length = string_tools::length(path);

  if (extension_index == npos || extension_index + 1 >= path_length)
  {
    return SourceFileType::None;
  }

  const auto *extension = path + extension_index + 1;

  return DefaultSourceFileTypeForExtension(
      FilePath::string_blob{ extension, path_length - extension_index - 1 });
}

SourceFileType build_tools::DefaultSourceFileTypeForFilePath(const FilePath &path) {
  return DefaultSourceFileTypeForFilePath(path.c_str());
}

SourceFileType build_tools::DefaultSourceFileTypeForExtension(FilePath::string_blob extension) {
  constexpr const FilePath::char_type *CPPExtensions[] = {
    "cpp", "c++", "cc", "cxx",

    "hpp", "h++", "hh", "hxx",
  };

  constexpr const FilePath::char_type *CExtensions[] = {
    "c",
    "h",
  };

#define CHECK_EXT(type, ext_list)                                       \
  for (size_t i = 0; i < std::size(ext_list); i++)                      \
  {                                                                     \
    if (string_tools::equal_insensitive(extension.data, (ext_list)[i])) \
    {                                                                   \
      return type;                                                      \
    }                                                                   \
  }

  CHECK_EXT(SourceFileType::CPP, CPPExtensions);
  CHECK_EXT(SourceFileType::C, CExtensions);

  return SourceFileType::None;
}

SourceFileType build_tools::DefaultSourceFileTypeForExtension(
    const FilePath::string_type &extension) {
  return DefaultSourceFileTypeForExtension(
      FilePath::string_blob{ extension.c_str(), extension.length() });
}

const char *build_tools::GetSourceFileTypeName(SourceFileType type) {
  switch (type)
  {
  case SourceFileType::C:
    return "C";
  case SourceFileType::CPP:
    return "Cpp";
  default:
    return "unknown";
  }
}

SourceFileType build_tools::GetFileTypeFromTypeName(FilePath::string_blob file_type_name) {
  return DefaultSourceFileTypeForExtension(file_type_name);  // yeah...
}

void build_tools::DumpDependencyMap(const SourceProcessor::dependency_info_map &map,
                                    const FilePath &output_dir) {
  const FilePath output_path = output_dir.join_path("dependency.txt");

  std::ofstream stream = output_path.stream_write(false);

  const std::streampos start = stream.tellp();

  WriteAutoGeneratedHeader(stream);
  stream << "# below is the dependency map of the entire project\n";

  // We can do it by converting 'map' to field var and save it
  // sadly, im too lazy rn

  for (const auto &[name, deps] : map)
  {
    stream << name << ":\n[\n";
    for (const auto &dep_name : deps.sub_dependencies)
    {
      stream << "  \"" << dep_name << "\", # " << FilePath(dep_name).resolved_copy(name.parent())
             << "\n";
    }
    stream << "]\n\n";
  }

  Logger::verbose("dumped the dependency map: size=%lld bytes", stream.tellp() - start);
}

string build_tools::JoinArguments(const std::string *args, size_t count) {
  std::ostringstream oss;

  for (size_t i = 0; i < count; i++)
  {
    bool need_enclosure =
        string_tools::all_of(args[i].c_str(), [](char value) { return !isgraph(value); });

    if (need_enclosure)
    {
      oss << '"' << args[i] << '"';
    }
    else
    {
      oss << args[i];
    }

    oss << ' ';
  }

  return oss.str();
}

bool DoesSourceTypeDominate(SourceFileType type, SourceFileType target) {
  constexpr std::pair<SourceFileType, SourceFileType> DominationTable[] = {
    { SourceFileType::CPP, SourceFileType::C },
  };

  // a type can not dominate it's own kind
  if (type == target)
  {
    return false;
  }

  // every type dominates the none type
  if (target == SourceFileType::None)
  {
    return true;
  }

  // the none type can't dominate any type
  if (type == SourceFileType::None)
  {
    return false;
  }

  for (const auto &i : DominationTable)
  {
    if (i == decltype(DominationTable[0]){ type, target })
    {
      return true;
    }
  }

  return false;
}

void GenerateJoinArgs(const Blob<const ExecuteParameter> &params, std::string *results) {

  for (size_t i = 0; i < params.length(); i++)
  {
    std::ostringstream oss;

    for (const string &str : params[i].args)
    {
      oss << str << ' ';
    }

    results[i] = oss.str();
    results[i].pop_back();
  }
}
